// Generated by DDC, the Dart Development Compiler (to JavaScript).
// Version: 3.1.3 (stable) (Tue Sep 26 14:25:13 2023 +0000) on "windows_x64"
// Module: packages/flutter/src/foundation/binding.dart
// Flags: soundNullSafety(true), enableAsserts(true)
define(['dart_sdk', 'packages/flutter/src/foundation/timeline.dart', 'packages/flutter/src/foundation/debug.dart', 'packages/flutter/src/foundation/service_extensions.dart', 'packages/flutter/src/foundation/_platform_web.dart', 'packages/flutter/src/foundation/print.dart', 'packages/flutter/src/foundation/object.dart'], (function load__packages__flutter__src__foundation__binding_dart(dart_sdk, packages__flutter__src__foundation__timeline$46dart, packages__flutter__src__foundation__debug$46dart, packages__flutter__src__foundation__service_extensions$46dart, packages__flutter__src__foundation___platform_web$46dart, packages__flutter__src__foundation__print$46dart, packages__flutter__src__foundation__object$46dart) {
  'use strict';
  const core = dart_sdk.core;
  const developer = dart_sdk.developer;
  const _js_helper = dart_sdk._js_helper;
  const ui = dart_sdk.ui;
  const async = dart_sdk.async;
  const _interceptors = dart_sdk._interceptors;
  const _internal = dart_sdk._internal;
  const convert = dart_sdk.convert;
  const io = dart_sdk.io;
  const dart = dart_sdk.dart;
  const dartx = dart_sdk.dartx;
  const timeline = packages__flutter__src__foundation__timeline$46dart.src__foundation__timeline;
  const assertions = packages__flutter__src__foundation__debug$46dart.src__foundation__assertions;
  const diagnostics = packages__flutter__src__foundation__debug$46dart.src__foundation__diagnostics;
  const debug = packages__flutter__src__foundation__debug$46dart.src__foundation__debug;
  const service_extensions = packages__flutter__src__foundation__service_extensions$46dart.src__foundation__service_extensions;
  const platform = packages__flutter__src__foundation___platform_web$46dart.src__foundation__platform;
  const print = packages__flutter__src__foundation__print$46dart.src__foundation__print;
  const object = packages__flutter__src__foundation__object$46dart.src__foundation__object;
  var binding = Object.create(dart.library);
  var $runtimeType = dartx.runtimeType;
  var $_equals = dartx._equals;
  var $containsKey = dartx.containsKey;
  var $_get = dartx._get;
  var $substring = dartx.substring;
  var $toString = dartx.toString;
  var $_set = dartx._set;
  dart._checkModuleNullSafetyMode(true);
  dart._checkModuleRuntimeTypes(false);
  var T$ = {
    VoidTobool: () => (T$.VoidTobool = dart.constFn(dart.fnType(core.bool, [])))(),
    IdentityMapOfString$String: () => (T$.IdentityMapOfString$String = dart.constFn(_js_helper.IdentityMap$(core.String, core.String)))(),
    JSArrayOfDiagnosticsNode: () => (T$.JSArrayOfDiagnosticsNode = dart.constFn(_interceptors.JSArray$(diagnostics.DiagnosticsNode)))(),
    FutureOfString: () => (T$.FutureOfString = dart.constFn(async.Future$(core.String)))(),
    VoidToFutureOfString: () => (T$.VoidToFutureOfString = dart.constFn(dart.fnType(T$.FutureOfString(), [])))(),
    FutureOfvoid: () => (T$.FutureOfvoid = dart.constFn(async.Future$(dart.void)))(),
    StringToFutureOfvoid: () => (T$.StringToFutureOfvoid = dart.constFn(dart.fnType(T$.FutureOfvoid(), [core.String])))(),
    IdentityMapOfString$dynamic: () => (T$.IdentityMapOfString$dynamic = dart.constFn(_js_helper.IdentityMap$(core.String, dart.dynamic)))(),
    MapOfString$dynamic: () => (T$.MapOfString$dynamic = dart.constFn(core.Map$(core.String, dart.dynamic)))(),
    FutureOfMapOfString$dynamic: () => (T$.FutureOfMapOfString$dynamic = dart.constFn(async.Future$(T$.MapOfString$dynamic())))(),
    MapOfString$String: () => (T$.MapOfString$String = dart.constFn(core.Map$(core.String, core.String)))(),
    MapOfString$StringToFutureOfMapOfString$dynamic: () => (T$.MapOfString$StringToFutureOfMapOfString$dynamic = dart.constFn(dart.fnType(T$.FutureOfMapOfString$dynamic(), [T$.MapOfString$String()])))(),
    VoidToNull: () => (T$.VoidToNull = dart.constFn(dart.fnType(core.Null, [])))(),
    VoidToFutureOfvoid: () => (T$.VoidToFutureOfvoid = dart.constFn(dart.fnType(T$.FutureOfvoid(), [])))(),
    FutureOfServiceExtensionResponse: () => (T$.FutureOfServiceExtensionResponse = dart.constFn(async.Future$(developer.ServiceExtensionResponse)))(),
    StringAndMapOfString$StringToFutureOfServiceExtensionResponse: () => (T$.StringAndMapOfString$StringToFutureOfServiceExtensionResponse = dart.constFn(dart.fnType(T$.FutureOfServiceExtensionResponse(), [core.String, T$.MapOfString$String()])))()
  };
  const CT = Object.create({
    _: () => (C, CT)
  });
  var I = [
    "file:///C:/Dev/flutter/packages/flutter/lib/src/foundation/binding.dart",
    "package:flutter/src/foundation/binding.dart"
  ];
  var _debugConstructed = dart.privateName(binding, "_debugConstructed");
  var _debugBindingZone = dart.privateName(binding, "_debugBindingZone");
  var _lockCount = dart.privateName(binding, "_lockCount");
  var _postExtensionStateChangedEvent = dart.privateName(binding, "_postExtensionStateChangedEvent");
  binding.BindingBase = class BindingBase extends core.Object {
    get window() {
      return ui.window;
    }
    get platformDispatcher() {
      return ui.PlatformDispatcher.instance;
    }
    initInstances() {
      if (!(binding.BindingBase._debugInitializedType == null)) dart.assertFailed(null, I[0], 285, 12, "_debugInitializedType == null");
      if (!dart.fn(() => {
        binding.BindingBase._debugInitializedType = this[$runtimeType];
        this[_debugBindingZone] = async.Zone.current;
        return true;
      }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 286, 12, "() {\r\n      _debugInitializedType = runtimeType;\r\n      _debugBindingZone = Zone.current;\r\n      return true;\r\n    }()");
    }
    static checkInstance(T, instance) {
      if (!dart.fn(() => {
        if (binding.BindingBase._debugInitializedType == null && instance == null) {
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("Binding has not yet been initialized."), new assertions.ErrorDescription.new("The \"instance\" getter on the " + dart.str(dart.wrapType(T)) + " binding mixin is only available once that binding has been initialized."), new assertions.ErrorHint.new("Typically, this is done by calling \"WidgetsFlutterBinding.ensureInitialized()\" or \"runApp()\" (the latter calls the former). Typically this call is done in the \"void main()\" method. The \"ensureInitialized\" method is idempotent; calling it multiple times is not harmful. After calling that method, the \"instance\" getter will return the binding."), new assertions.ErrorHint.new("In a test, one can call \"TestWidgetsFlutterBinding.ensureInitialized()\" as the first line in the test's \"main()\" method to initialize the binding."), new assertions.ErrorHint.new("If " + dart.str(dart.wrapType(T)) + " is a custom binding mixin, there must also be a custom binding class, like WidgetsFlutterBinding, " + "but that mixes in the selected binding, and that is the class that must be constructed before using the \"instance\" getter.")])));
        }
        if (instance == null) {
          if (!(binding.BindingBase._debugInitializedType == null)) dart.assertFailed(null, I[0], 328, 16, "_debugInitializedType == null");
          dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("Binding mixin instance is null but bindings are already initialized."), new assertions.ErrorDescription.new("The \"instance\" property of the " + dart.str(dart.wrapType(T)) + " binding mixin was accessed, but that binding was not initialized when " + "the \"initInstances()\" method was called."), new assertions.ErrorHint.new("This probably indicates that the " + dart.str(dart.wrapType(T)) + " mixin was not mixed into the class that was used to initialize the binding. " + "If this is a custom binding mixin, there must also be a custom binding class, like WidgetsFlutterBinding, " + "but that mixes in the selected binding. If this is a test binding, check that the binding being initialized " + "is the same as the one into which the test binding is mixed."), new assertions.ErrorHint.new("It is also possible that " + dart.str(dart.wrapType(T)) + " does not implement \"initInstances()\" to assign a value to \"instance\". See the " + "documentation of the BindingBase class for more details."), new assertions.ErrorHint.new("The binding that was initialized was of the type \"" + dart.str(binding.BindingBase._debugInitializedType) + "\". ")])));
        }
        try {
          if (instance[_debugConstructed] && binding.BindingBase._debugInitializedType == null) {
            dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("Binding initialized without calling initInstances."), new assertions.ErrorDescription.new("An instance of " + dart.str(dart.wrapType(T)) + " is non-null, but BindingBase.initInstances() has not yet been called."), new assertions.ErrorHint.new("This could happen because a binding mixin was somehow used outside of the normal binding mechanisms, or because the binding's initInstances() method did not call \"super.initInstances()\"."), new assertions.ErrorHint.new("This could also happen if some code was invoked that used the binding while the binding was initializing, for example if the \"initInstances\" method invokes a callback. Bindings should not invoke callbacks before \"initInstances\" has completed.")])));
          }
          if (!instance[_debugConstructed]) {
            dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("Binding did not complete initialization."), new assertions.ErrorDescription.new("An instance of " + dart.str(dart.wrapType(T)) + " is non-null, but the BindingBase() constructor has not yet been called."), new assertions.ErrorHint.new("This could also happen if some code was invoked that used the binding while the binding was initializing, for example if the binding's constructor itself invokes a callback. Bindings should not invoke callbacks before \"initInstances\" has completed.")])));
          }
        } catch (t$36$35e) {
          let t$36$35ex = dart.getThrown(t$36$35e);
          if (core.NoSuchMethodError.is(t$36$35ex)) {
            dart.throw(new assertions.FlutterError.fromParts(T$.JSArrayOfDiagnosticsNode().of([new assertions.ErrorSummary.new("Binding does not extend BindingBase"), new assertions.ErrorDescription.new("An instance of " + dart.str(dart.wrapType(T)) + " was created but the BindingBase constructor was not called."), new assertions.ErrorHint.new("This could happen because the binding was implemented using \"implements\" rather than \"extends\" or \"with\". Concrete binding classes must extend or mix in BindingBase.")])));
          } else
            throw t$36$35e;
        }
        return true;
      }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 306, 12, "() {\r\n      if (_debugInitializedType == null && instance == null) {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('Binding has not yet been initialized.'),\r\n          ErrorDescription('The \"instance\" getter on the $T binding mixin is only available once that binding has been initialized.'),\r\n          ErrorHint(\r\n            'Typically, this is done by calling \"WidgetsFlutterBinding.ensureInitialized()\" or \"runApp()\" (the '\r\n            'latter calls the former). Typically this call is done in the \"void main()\" method. The \"ensureInitialized\" method '\r\n            'is idempotent; calling it multiple times is not harmful. After calling that method, the \"instance\" getter will '\r\n            'return the binding.',\r\n          ),\r\n          ErrorHint(\r\n            'In a test, one can call \"TestWidgetsFlutterBinding.ensureInitialized()\" as the first line in the test\\'s \"main()\" method '\r\n            'to initialize the binding.',\r\n          ),\r\n          ErrorHint(\r\n            'If $T is a custom binding mixin, there must also be a custom binding class, like WidgetsFlutterBinding, '\r\n            'but that mixes in the selected binding, and that is the class that must be constructed before using the \"instance\" getter.',\r\n          ),\r\n        ]);\r\n      }\r\n      if (instance == null) {\r\n        assert(_debugInitializedType == null);\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('Binding mixin instance is null but bindings are already initialized.'),\r\n          ErrorDescription(\r\n            'The \"instance\" property of the $T binding mixin was accessed, but that binding was not initialized when '\r\n            'the \"initInstances()\" method was called.',\r\n          ),\r\n          ErrorHint(\r\n            'This probably indicates that the $T mixin was not mixed into the class that was used to initialize the binding. '\r\n            'If this is a custom binding mixin, there must also be a custom binding class, like WidgetsFlutterBinding, '\r\n            'but that mixes in the selected binding. If this is a test binding, check that the binding being initialized '\r\n            'is the same as the one into which the test binding is mixed.',\r\n          ),\r\n          ErrorHint(\r\n            'It is also possible that $T does not implement \"initInstances()\" to assign a value to \"instance\". See the '\r\n            'documentation of the BindingBase class for more details.',\r\n          ),\r\n          ErrorHint(\r\n            'The binding that was initialized was of the type \"$_debugInitializedType\". '\r\n          ),\r\n        ]);\r\n      }\r\n      try {\r\n        if (instance._debugConstructed && _debugInitializedType == null) {\r\n          throw FlutterError.fromParts(<DiagnosticsNode>[\r\n            ErrorSummary('Binding initialized without calling initInstances.'),\r\n            ErrorDescription('An instance of $T is non-null, but BindingBase.initInstances() has not yet been called.'),\r\n            ErrorHint(\r\n              'This could happen because a binding mixin was somehow used outside of the normal binding mechanisms, or because '\r\n              'the binding\\'s initInstances() method did not call \"super.initInstances()\".',\r\n            ),\r\n            ErrorHint(\r\n              'This could also happen if some code was invoked that used the binding while the binding was initializing, '\r\n              'for example if the \"initInstances\" method invokes a callback. Bindings should not invoke callbacks before '\r\n              '\"initInstances\" has completed.',\r\n            ),\r\n          ]);\r\n        }\r\n        if (!instance._debugConstructed) {\r\n          // The state of _debugInitializedType doesn't matter in this failure mode.\r\n          throw FlutterError.fromParts(<DiagnosticsNode>[\r\n            ErrorSummary('Binding did not complete initialization.'),\r\n            ErrorDescription('An instance of $T is non-null, but the BindingBase() constructor has not yet been called.'),\r\n            ErrorHint(\r\n              'This could also happen if some code was invoked that used the binding while the binding was initializing, '\r\n              \"for example if the binding's constructor itself invokes a callback. Bindings should not invoke callbacks \"\r\n              'before \"initInstances\" has completed.',\r\n            ),\r\n          ]);\r\n        }\r\n      } on NoSuchMethodError {\r\n        throw FlutterError.fromParts(<DiagnosticsNode>[\r\n          ErrorSummary('Binding does not extend BindingBase'),\r\n          ErrorDescription('An instance of $T was created but the BindingBase constructor was not called.'),\r\n          ErrorHint(\r\n            'This could happen because the binding was implemented using \"implements\" rather than \"extends\" or \"with\". '\r\n            'Concrete binding classes must extend or mix in BindingBase.',\r\n          ),\r\n        ]);\r\n      }\r\n      return true;\r\n    }()");
      return dart.nullCheck(instance);
    }
    static debugBindingType() {
      return binding.BindingBase._debugInitializedType;
    }
    debugCheckZone(entryPoint) {
      if (!dart.fn(() => {
        if (!(this[_debugBindingZone] != null)) dart.assertFailed("debugCheckZone can only be used after the binding is fully initialized.", I[0], 483, 14, "_debugBindingZone != null");
        if (!async.Zone.current[$_equals](this[_debugBindingZone])) {
          let message = assertions.FlutterError.new("Zone mismatch.\n" + "The Flutter bindings were initialized in a different zone than is now being used. " + "This will likely cause confusion and bugs as any zone-specific configuration will " + "inconsistently use the configuration of the original binding initialization zone " + "or this zone based on hard-to-predict factors such as which zone was active when " + "a particular callback was set.\n" + "It is important to use the same zone when calling `ensureInitialized` on the binding " + "as when calling `" + entryPoint + "` later.\n" + "To make this " + (binding.BindingBase.debugZoneErrorsAreFatal ? "error non-fatal" : "warning fatal") + ", " + "set BindingBase.debugZoneErrorsAreFatal to " + dart.str(!binding.BindingBase.debugZoneErrorsAreFatal) + " before the " + "bindings are initialized (i.e. as the first statement in `void main() { }`).");
          if (binding.BindingBase.debugZoneErrorsAreFatal) {
            dart.throw(message);
          }
          assertions.FlutterError.reportError(new assertions.FlutterErrorDetails.new({exception: message, stack: core.StackTrace.current, context: new assertions.ErrorDescription.new("during " + entryPoint)}));
        }
        return true;
      }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 482, 12, "() {\r\n      assert(_debugBindingZone != null, 'debugCheckZone can only be used after the binding is fully initialized.');\r\n      if (Zone.current != _debugBindingZone) {\r\n        final Error message = FlutterError(\r\n          'Zone mismatch.\\n'\r\n          'The Flutter bindings were initialized in a different zone than is now being used. '\r\n          'This will likely cause confusion and bugs as any zone-specific configuration will '\r\n          'inconsistently use the configuration of the original binding initialization zone '\r\n          'or this zone based on hard-to-predict factors such as which zone was active when '\r\n          'a particular callback was set.\\n'\r\n          'It is important to use the same zone when calling `ensureInitialized` on the binding '\r\n          'as when calling `$entryPoint` later.\\n'\r\n          'To make this ${ debugZoneErrorsAreFatal ? 'error non-fatal' : 'warning fatal' }, '\r\n          'set BindingBase.debugZoneErrorsAreFatal to ${!debugZoneErrorsAreFatal} before the '\r\n          'bindings are initialized (i.e. as the first statement in `void main() { }`).',\r\n        );\r\n        if (debugZoneErrorsAreFatal) {\r\n          throw message;\r\n        }\r\n        FlutterError.reportError(FlutterErrorDetails(\r\n          exception: message,\r\n          stack: StackTrace.current,\r\n          context: ErrorDescription('during $entryPoint'),\r\n        ));\r\n      }\r\n      return true;\r\n    }()");
      return true;
    }
    initServiceExtensions() {
      if (!!binding.BindingBase._debugServiceExtensionsRegistered) dart.assertFailed(null, I[0], 533, 12, "!_debugServiceExtensionsRegistered");
      if (!dart.fn(() => {
        this.registerSignalServiceExtension({name: core['EnumName|get#name'](service_extensions.FoundationServiceExtensions.reassemble), callback: dart.bind(this, 'reassembleApplication')});
        return true;
      }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 535, 12, "() {\r\n      registerSignalServiceExtension(\r\n        name: FoundationServiceExtensions.reassemble.name,\r\n        callback: reassembleApplication,\r\n      );\r\n      return true;\r\n    }()");
      {
        ;
        this.registerStringServiceExtension({name: core['EnumName|get#name'](service_extensions.FoundationServiceExtensions.connectedVmServiceUri), getter: dart.fn(() => async.async(core.String, function*() {
            let t$362;
            t$362 = debug.connectedVmServiceUri;
            return t$362 == null ? "" : t$362;
          }), T$.VoidToFutureOfString()), setter: dart.fn(uri => async.async(dart.void, function*() {
            debug.connectedVmServiceUri = uri;
          }), T$.StringToFutureOfvoid())});
        this.registerStringServiceExtension({name: core['EnumName|get#name'](service_extensions.FoundationServiceExtensions.activeDevToolsServerAddress), getter: dart.fn(() => async.async(core.String, function*() {
            let t$362;
            t$362 = debug.activeDevToolsServerAddress;
            return t$362 == null ? "" : t$362;
          }), T$.VoidToFutureOfString()), setter: dart.fn(serverAddress => async.async(dart.void, function*() {
            debug.activeDevToolsServerAddress = serverAddress;
          }), T$.StringToFutureOfvoid())});
      }
      if (!dart.fn(() => {
        this.registerServiceExtension({name: core['EnumName|get#name'](service_extensions.FoundationServiceExtensions.platformOverride), callback: dart.fn(parameters => async.async(T$.MapOfString$dynamic(), (function*() {
            if (parameters[$containsKey]("value")) {
              switch (parameters[$_get]("value")) {
                case "android":
                  {
                    platform.debugDefaultTargetPlatformOverride = platform.TargetPlatform.android;
                    break;
                  }
                case "fuchsia":
                  {
                    platform.debugDefaultTargetPlatformOverride = platform.TargetPlatform.fuchsia;
                    break;
                  }
                case "iOS":
                  {
                    platform.debugDefaultTargetPlatformOverride = platform.TargetPlatform.iOS;
                    break;
                  }
                case "linux":
                  {
                    platform.debugDefaultTargetPlatformOverride = platform.TargetPlatform.linux;
                    break;
                  }
                case "macOS":
                  {
                    platform.debugDefaultTargetPlatformOverride = platform.TargetPlatform.macOS;
                    break;
                  }
                case "windows":
                  {
                    platform.debugDefaultTargetPlatformOverride = platform.TargetPlatform.windows;
                    break;
                  }
                case "default":
                default:
                  {
                    platform.debugDefaultTargetPlatformOverride = null;
                  }
              }
              this[_postExtensionStateChangedEvent](core['EnumName|get#name'](service_extensions.FoundationServiceExtensions.platformOverride), platform.defaultTargetPlatform.toString()[$substring]((dart.str(dart.wrapType(platform.TargetPlatform)) + ".").length));
              yield this.reassembleApplication();
            }
            return new (T$.IdentityMapOfString$dynamic()).from(["value", platform.defaultTargetPlatform.toString()[$substring]((dart.str(dart.wrapType(platform.TargetPlatform)) + ".").length)]);
          }).bind(this)), T$.MapOfString$StringToFutureOfMapOfString$dynamic())});
        this.registerServiceExtension({name: core['EnumName|get#name'](service_extensions.FoundationServiceExtensions.brightnessOverride), callback: dart.fn(parameters => async.async(T$.MapOfString$dynamic(), (function*() {
            let t$362, t$362$;
            if (parameters[$containsKey]("value")) {
              switch (parameters[$_get]("value")) {
                case "Brightness.light":
                  {
                    debug.debugBrightnessOverride = ui.Brightness.light;
                    break;
                  }
                case "Brightness.dark":
                  {
                    debug.debugBrightnessOverride = ui.Brightness.dark;
                    break;
                  }
                default:
                  {
                    debug.debugBrightnessOverride = null;
                  }
              }
              this[_postExtensionStateChangedEvent](core['EnumName|get#name'](service_extensions.FoundationServiceExtensions.brightnessOverride), dart.toString((t$362 = debug.debugBrightnessOverride, t$362 == null ? this.platformDispatcher.platformBrightness : t$362)));
              yield this.reassembleApplication();
            }
            return new (T$.IdentityMapOfString$dynamic()).from(["value", dart.toString((t$362$ = debug.debugBrightnessOverride, t$362$ == null ? this.platformDispatcher.platformBrightness : t$362$))]);
          }).bind(this)), T$.MapOfString$StringToFutureOfMapOfString$dynamic())});
        return true;
      }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 567, 12, "() {\r\n      registerServiceExtension(\r\n        name: FoundationServiceExtensions.platformOverride.name,\r\n        callback: (Map<String, String> parameters) async {\r\n          if (parameters.containsKey('value')) {\r\n            switch (parameters['value']) {\r\n              case 'android':\r\n                debugDefaultTargetPlatformOverride = TargetPlatform.android;\r\n              case 'fuchsia':\r\n                debugDefaultTargetPlatformOverride = TargetPlatform.fuchsia;\r\n              case 'iOS':\r\n                debugDefaultTargetPlatformOverride = TargetPlatform.iOS;\r\n              case 'linux':\r\n                debugDefaultTargetPlatformOverride = TargetPlatform.linux;\r\n              case 'macOS':\r\n                debugDefaultTargetPlatformOverride = TargetPlatform.macOS;\r\n              case 'windows':\r\n                debugDefaultTargetPlatformOverride = TargetPlatform.windows;\r\n              case 'default':\r\n              default:\r\n                debugDefaultTargetPlatformOverride = null;\r\n            }\r\n            _postExtensionStateChangedEvent(\r\n              FoundationServiceExtensions.platformOverride.name,\r\n              defaultTargetPlatform.toString().substring('$TargetPlatform.'.length),\r\n            );\r\n            await reassembleApplication();\r\n          }\r\n          return <String, dynamic>{\r\n            'value': defaultTargetPlatform\r\n                     .toString()\r\n                     .substring('$TargetPlatform.'.length),\r\n          };\r\n        },\r\n      );\r\n\r\n      registerServiceExtension(\r\n        name: FoundationServiceExtensions.brightnessOverride.name,\r\n        callback: (Map<String, String> parameters) async {\r\n          if (parameters.containsKey('value')) {\r\n            switch (parameters['value']) {\r\n              case 'Brightness.light':\r\n                debugBrightnessOverride = ui.Brightness.light;\r\n              case 'Brightness.dark':\r\n                debugBrightnessOverride = ui.Brightness.dark;\r\n              default:\r\n                debugBrightnessOverride = null;\r\n            }\r\n            _postExtensionStateChangedEvent(\r\n              FoundationServiceExtensions.brightnessOverride.name,\r\n              (debugBrightnessOverride ?? platformDispatcher.platformBrightness).toString(),\r\n            );\r\n            await reassembleApplication();\r\n          }\r\n          return <String, dynamic>{\r\n            'value': (debugBrightnessOverride ?? platformDispatcher.platformBrightness).toString(),\r\n          };\r\n        },\r\n      );\r\n      return true;\r\n    }()");
      if (!dart.fn(() => {
        binding.BindingBase._debugServiceExtensionsRegistered = true;
        return true;
      }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 628, 12, "() {\r\n      _debugServiceExtensionsRegistered = true;\r\n      return true;\r\n    }()");
    }
    get locked() {
      return this[_lockCount] > 0;
    }
    lockEvents(callback) {
      let t$362;
      let timelineTask = (t$362 = new developer.TimelineTask.new(), (() => {
        t$362.start("Lock events");
        return t$362;
      })());
      this[_lockCount] = this[_lockCount] + 1;
      let future = callback();
      future.whenComplete(dart.fn(() => {
        this[_lockCount] = this[_lockCount] - 1;
        if (!this.locked) {
          timelineTask.finish();
          try {
            this.unlocked();
          } catch (t$36$35e) {
            let error = dart.getThrown(t$36$35e);
            let stack = dart.stackTrace(t$36$35e);
            if (core.Object.is(error)) {
              assertions.FlutterError.reportError(new assertions.FlutterErrorDetails.new({exception: error, stack: stack, library: "foundation", context: new assertions.ErrorDescription.new("while handling pending events")}));
            } else
              throw t$36$35e;
          }
        }
      }, T$.VoidToNull()));
      return future;
    }
    unlocked() {
      if (!!this.locked) dart.assertFailed(null, I[0], 689, 12, "!locked");
    }
    reassembleApplication() {
      return this.lockEvents(dart.bind(this, 'performReassemble'));
    }
    performReassemble() {
      assertions.FlutterError.resetErrorCount();
      return T$.FutureOfvoid().value();
    }
    registerSignalServiceExtension(opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let callback = opts && 'callback' in opts ? opts.callback : null;
      this.registerServiceExtension({name: name, callback: dart.fn(parameters => async.async(T$.MapOfString$dynamic(), function*() {
          yield callback();
          return new (T$.IdentityMapOfString$dynamic()).new();
        }), T$.MapOfString$StringToFutureOfMapOfString$dynamic())});
    }
    registerBoolServiceExtension(opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let getter = opts && 'getter' in opts ? opts.getter : null;
      let setter = opts && 'setter' in opts ? opts.setter : null;
      this.registerServiceExtension({name: name, callback: dart.fn(parameters => async.async(T$.MapOfString$dynamic(), (function*() {
          if (parameters[$containsKey]("enabled")) {
            yield setter(parameters[$_get]("enabled") === "true");
            this[_postExtensionStateChangedEvent](name, (yield getter()) ? "true" : "false");
          }
          return new (T$.IdentityMapOfString$dynamic()).from(["enabled", (yield getter()) ? "true" : "false"]);
        }).bind(this)), T$.MapOfString$StringToFutureOfMapOfString$dynamic())});
    }
    registerNumericServiceExtension(opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let getter = opts && 'getter' in opts ? opts.getter : null;
      let setter = opts && 'setter' in opts ? opts.setter : null;
      this.registerServiceExtension({name: name, callback: dart.fn(parameters => async.async(T$.MapOfString$dynamic(), (function*() {
          if (parameters[$containsKey](name)) {
            yield setter(core.double.parse(dart.nullCheck(parameters[$_get](name))));
            this[_postExtensionStateChangedEvent](name, (yield getter())[$toString]());
          }
          return new (T$.IdentityMapOfString$dynamic()).from([name, (yield getter())[$toString]()]);
        }).bind(this)), T$.MapOfString$StringToFutureOfMapOfString$dynamic())});
    }
    [_postExtensionStateChangedEvent](name, value) {
      this.postEvent("Flutter.ServiceExtensionStateChanged", new (T$.IdentityMapOfString$dynamic()).from(["extension", "ext.flutter." + name, "value", value]));
    }
    postEvent(eventKind, eventData) {
      developer.postEvent(eventKind, eventData);
    }
    registerStringServiceExtension(opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let getter = opts && 'getter' in opts ? opts.getter : null;
      let setter = opts && 'setter' in opts ? opts.setter : null;
      this.registerServiceExtension({name: name, callback: dart.fn(parameters => async.async(T$.MapOfString$dynamic(), (function*() {
          if (parameters[$containsKey]("value")) {
            yield setter(dart.nullCheck(parameters[$_get]("value")));
            this[_postExtensionStateChangedEvent](name, yield getter());
          }
          return new (T$.IdentityMapOfString$dynamic()).from(["value", (yield getter())]);
        }).bind(this)), T$.MapOfString$StringToFutureOfMapOfString$dynamic())});
    }
    registerServiceExtension(opts) {
      let name = opts && 'name' in opts ? opts.name : null;
      let callback = opts && 'callback' in opts ? opts.callback : null;
      let methodName = "ext.flutter." + name;
      developer.registerExtension(methodName, dart.fn((method, parameters) => async.async(developer.ServiceExtensionResponse, function*() {
        if (!(method === methodName)) dart.assertFailed(null, I[0], 934, 14, "method == methodName");
        if (!dart.fn(() => {
          if (debug.debugInstrumentationEnabled) {
            print.debugPrint("service extension method received: " + method + "(" + dart.str(parameters) + ")");
          }
          return true;
        }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 935, 14, "() {\r\n        if (debugInstrumentationEnabled) {\r\n          debugPrint('service extension method received: $method($parameters)');\r\n        }\r\n        return true;\r\n      }()");
        yield debug.debugInstrumentAction(dart.void, "Wait for outer event loop", dart.fn(() => T$.FutureOfvoid().delayed(core.Duration.zero), T$.VoidToFutureOfvoid()));
        let t$36$35result = null;
        function t$36$35result$35get() {
          let t$364;
          t$364 = t$36$35result;
          return t$364 == null ? dart.throw(new _internal.LateError.localNI("result")) : t$364;
        }
        function t$36$35result$35set(result$35param) {
          return t$36$35result = result$35param;
        }
        try {
          t$36$35result$35set(yield callback(parameters));
        } catch (t$36$35e) {
          let exception = dart.getThrown(t$36$35e);
          let stack = dart.stackTrace(t$36$35e);
          if (core.Object.is(exception)) {
            assertions.FlutterError.reportError(new assertions.FlutterErrorDetails.new({exception: exception, stack: stack, context: new assertions.ErrorDescription.new("during a service extension callback for \"" + method + "\"")}));
            return new developer.ServiceExtensionResponse.error(-32000, convert.json.encode(new (T$.IdentityMapOfString$String()).from(["exception", exception[$toString](), "stack", stack.toString(), "method", method])));
          } else
            throw t$36$35e;
        }
        t$36$35result$35get()[$_set]("type", "_extensionType");
        t$36$35result$35get()[$_set]("method", method);
        return new developer.ServiceExtensionResponse.result(convert.json.encode(t$36$35result$35get()));
      }), T$.StringAndMapOfString$StringToFutureOfServiceExtensionResponse()));
    }
    toString() {
      return "<" + object.objectRuntimeType(this, "BindingBase") + ">";
    }
  };
  (binding.BindingBase.new = function() {
    this[_debugConstructed] = false;
    this[_debugBindingZone] = null;
    this[_lockCount] = 0;
    {
      timeline.FlutterTimeline.startSync("Framework initialization");
    }
    if (!dart.fn(() => {
      this[_debugConstructed] = true;
      return true;
    }, T$.VoidTobool())()) dart.assertFailed(null, I[0], 148, 12, "() {\r\n      _debugConstructed = true;\r\n      return true;\r\n    }()");
    if (!(binding.BindingBase._debugInitializedType == null)) dart.assertFailed("Binding is already initialized to " + dart.str(binding.BindingBase._debugInitializedType), I[0], 153, 12, "_debugInitializedType == null");
    this.initInstances();
    if (!(binding.BindingBase._debugInitializedType != null)) dart.assertFailed(null, I[0], 155, 12, "_debugInitializedType != null");
    if (!!binding.BindingBase._debugServiceExtensionsRegistered) dart.assertFailed(null, I[0], 157, 12, "!_debugServiceExtensionsRegistered");
    this.initServiceExtensions();
    if (!binding.BindingBase._debugServiceExtensionsRegistered) dart.assertFailed(null, I[0], 159, 12, "_debugServiceExtensionsRegistered");
    developer.postEvent("Flutter.FrameworkInitialization", new (T$.IdentityMapOfString$String()).new());
    {
      timeline.FlutterTimeline.finishSync();
    }
  }).prototype = binding.BindingBase.prototype;
  dart.addTypeTests(binding.BindingBase);
  dart.addTypeCaches(binding.BindingBase);
  dart.setMethodSignature(binding.BindingBase, () => dart.global.Object.setPrototypeOf({
    initInstances: dart.fnType(dart.void, []),
    debugCheckZone: dart.fnType(core.bool, [core.String]),
    initServiceExtensions: dart.fnType(dart.void, []),
    lockEvents: dart.fnType(async.Future$(dart.void), [dart.fnType(async.Future$(dart.void), [])]),
    unlocked: dart.fnType(dart.void, []),
    reassembleApplication: dart.fnType(async.Future$(dart.void), []),
    performReassemble: dart.fnType(async.Future$(dart.void), []),
    registerSignalServiceExtension: dart.fnType(dart.void, [], {}, {callback: dart.fnType(async.Future$(dart.void), []), name: core.String}),
    registerBoolServiceExtension: dart.fnType(dart.void, [], {}, {getter: dart.fnType(async.Future$(core.bool), []), name: core.String, setter: dart.fnType(async.Future$(dart.void), [core.bool])}),
    registerNumericServiceExtension: dart.fnType(dart.void, [], {}, {getter: dart.fnType(async.Future$(core.double), []), name: core.String, setter: dart.fnType(async.Future$(dart.void), [core.double])}),
    [_postExtensionStateChangedEvent]: dart.fnType(dart.void, [core.String, dart.dynamic]),
    postEvent: dart.fnType(dart.void, [core.String, core.Map$(core.String, dart.dynamic)]),
    registerStringServiceExtension: dart.fnType(dart.void, [], {}, {getter: dart.fnType(async.Future$(core.String), []), name: core.String, setter: dart.fnType(async.Future$(dart.void), [core.String])}),
    registerServiceExtension: dart.fnType(dart.void, [], {}, {callback: dart.fnType(async.Future$(core.Map$(core.String, dart.dynamic)), [core.Map$(core.String, core.String)]), name: core.String})
  }, dart.getMethods(dart.global.Object.getPrototypeOf(binding.BindingBase))));
  dart.setStaticMethodSignature(binding.BindingBase, () => ['checkInstance', 'debugBindingType']);
  dart.setGetterSignature(binding.BindingBase, () => dart.global.Object.setPrototypeOf({
    window: ui.SingletonFlutterWindow,
    platformDispatcher: ui.PlatformDispatcher,
    locked: core.bool
  }, dart.getGetters(dart.global.Object.getPrototypeOf(binding.BindingBase))));
  dart.setLibraryUri(binding.BindingBase, I[1]);
  dart.setFieldSignature(binding.BindingBase, () => dart.global.Object.setPrototypeOf({
    [_debugConstructed]: dart.fieldType(core.bool),
    [_debugBindingZone]: dart.fieldType(dart.nullable(async.Zone)),
    [_lockCount]: dart.fieldType(core.int)
  }, dart.getFields(dart.global.Object.getPrototypeOf(binding.BindingBase))));
  dart.setStaticFieldSignature(binding.BindingBase, () => ['_debugInitializedType', '_debugServiceExtensionsRegistered', 'debugReassembleConfig', 'debugZoneErrorsAreFatal']);
  dart.defineExtensionMethods(binding.BindingBase, ['toString']);
  dart.defineLazy(binding.BindingBase, {
    /*binding.BindingBase._debugInitializedType*/get _debugInitializedType() {
      return null;
    },
    set _debugInitializedType(value) {},
    /*binding.BindingBase._debugServiceExtensionsRegistered*/get _debugServiceExtensionsRegistered() {
      return false;
    },
    set _debugServiceExtensionsRegistered(value) {},
    /*binding.BindingBase.debugReassembleConfig*/get debugReassembleConfig() {
      return null;
    },
    set debugReassembleConfig(value) {},
    /*binding.BindingBase.debugZoneErrorsAreFatal*/get debugZoneErrorsAreFatal() {
      return false;
    },
    set debugZoneErrorsAreFatal(value) {}
  }, false);
  var widgetName$ = dart.privateName(binding, "DebugReassembleConfig.widgetName");
  binding.DebugReassembleConfig = class DebugReassembleConfig extends core.Object {
    get widgetName() {
      return this[widgetName$];
    }
    set widgetName(value) {
      super.widgetName = value;
    }
    static ['_#new#tearOff'](opts) {
      let widgetName = opts && 'widgetName' in opts ? opts.widgetName : null;
      return new binding.DebugReassembleConfig.new({widgetName: widgetName});
    }
  };
  (binding.DebugReassembleConfig.new = function(opts) {
    let widgetName = opts && 'widgetName' in opts ? opts.widgetName : null;
    this[widgetName$] = widgetName;
    ;
  }).prototype = binding.DebugReassembleConfig.prototype;
  dart.addTypeTests(binding.DebugReassembleConfig);
  dart.addTypeCaches(binding.DebugReassembleConfig);
  dart.setLibraryUri(binding.DebugReassembleConfig, I[1]);
  dart.setFieldSignature(binding.DebugReassembleConfig, () => dart.global.Object.setPrototypeOf({widgetName: dart.finalFieldType(dart.nullable(core.String))}, dart.getFields(dart.global.Object.getPrototypeOf(binding.DebugReassembleConfig))));
  binding._exitApplication = function _exitApplication() {
    return async.async(dart.void, function* _exitApplication() {
      io.exit(0);
    });
  };
  dart.trackLibraries("packages/flutter/src/foundation/binding.dart", {
    "package:flutter/src/foundation/binding.dart": binding
  }, {
  }, '{"version":3,"sourceRoot":"","sources":["binding.dart"],"names":[],"mappings":"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","file":"../../../../../../../packages/flutter/src/foundation/binding.dart.lib.js"}');
  // Exports:
  return {
    src__foundation__binding: binding
  };
}));

//# sourceMappingURL=binding.dart.lib.js.map
